#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#define min(A,B) A<B?A:B
// min 매크로는 두 값 중 작은 값을 반환함 
int arr[1000001];

/*
우리가 할 수 있는 연산은 다음과 같다
1. 현재의 수에서 1을 빼기
2. 현재 수가 3으로 나누어떨어지면 3으로 나누기
3. 현재 수가 2로 나누어떨어지면 2로 나누기
이 알고리즘은 arr 배열을 사용하여 각 숫자에 대해 1로 만드는 데 필요한 최소 연산 횟수를 저장한다.
*/
// 동적 계획법으로 코드를 작성함 => num[i] = mmin(arr[i-1], arr[i/3],arr[i/2])+1

/*
동적 프로그래밍은(DP)은 복잡한 문제를 더 작은 하위 문제로 나누어 해결하고, 그 결과를 저장하여 재사용하는 방법임.
숫자 i를 1로 만드는 최소 연산 횟수를 계산하기 위해 arr 배열을 사용함.
*/

/*
예를 들어 10을 입력하면, i를 증가함
i = 2 >> 2에서 1로 만드는데 1번의 연산이 필요
i = 3 >> 3에서 1로 만드는데 1번의 연산이 필요 
i = 4 >> 4에서 1로 만드는데 2번의 연산이 필요
i = 5 >> 5에서 1로 만드는데 3번의 연산이 필요
i = 6 >> 6에서 1로 만드는데 3번의 연산이 필요
i = 7 >> 7에서 1로 만드는데 3번의 연산이 필요
i = 8 >> 8에서 1로 만드는데 3번의 연산이 필요
i = 9 >> 9에서 1로 만드는데 2번의 연산이 필요
i = 10 >> 10에서 1로 만드는데 3번의 연산이 필요

이전까지 필요한 연산들은 이미 만들었기에 곧바로 구할 수 있음
*/

int main() {
    int X;
    // 정수 X를 1로 만드는 연산 횟수의 최솟값은 arr[X]로 출력 
    scanf("%d", &X);
    //arr[i]는 i를 1로 만드는데 필요한 최소 연산 횟수임 
    for (int i = 2; i <= X; i++) {
        arr[i] = arr[i - 1] + 1;
        // i에서 1을 뺀 경우의 연산 횟수를 저장함 
        if (i % 3 == 0)
            arr[i] = min(arr[i], arr[i / 3] + 1);
        //i가 3으로 나누어 떨어질 때 arr[i] 값을 arr[i/3]+1과 비교하여 더 작은 값으로 갱신함
        if (i % 2 == 0)
            arr[i] = min(arr[i], arr[i / 2] + 1);
    }   //i가 2로 나누어 떨어질 떄 arr[i] 값을 arr[i/2]+1과 비교하여 더 작은 값으로 갱신함
    printf("%d", arr[X]);
    return 0;
}